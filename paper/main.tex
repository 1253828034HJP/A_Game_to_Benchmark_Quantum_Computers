\documentclass[aps,prl,twocolumn,showpacs,preprintnumbers]{revtex4-1}

% Package(s) to include
\usepackage{psfrag,graphicx}
\usepackage{dcolumn}
\usepackage{amsmath,amssymb}
\usepackage{bm}
\usepackage{amsfonts,amssymb,amsmath}        % for math symbols.
\usepackage{epstopdf}
\usepackage{mathtools}
\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}

\newcommand{\be}{\begin{equation}}
\newcommand{\ee}{\end{equation}}
\newcommand{\bq}{\begin{eqnarray}}
\newcommand{\eq}{\end{eqnarray}}

\newcommand{\twoDEG}{\textsc{2deg}}
\newcommand{\SOI}{\textsc{soi}}

\newcommand{\ket}[1]{\left | \, #1 \right\rangle}
\newcommand{\bra}[1]{\left \langle #1 \, \right |}


\bibliographystyle{apsrev}

\begin{document}
\title{Benchmarking of quantum processors with random circuits}
\author{James R. Wootton}
\affiliation{Department of Physics, University of Basel, Klingelbergstrasse 82, CH-4056 Basel, Switzerland}


\begin{abstract}

Quantum processors with sizes in the 10-100 qubit range are now commonplace. However, with increased size comes increased complexity for benchmarking. The effectiveness of a given device may vary greatly between different tasks, and wonâ€™t always be  easy to predict from single and two qubit gate fidelities. For this reason, it is important to assess processor quality for a range of important tasks. In this work we propose and implement tests based on random quantum circuits. These are used to evaluate four different superconducting qubit devices, with sizes from 5 to 19 qubits, from three hardware manufacturers: IBM Research, Rigetti and Alibaba.


\end{abstract}


\pacs{}

\maketitle


\section{Introduction}

~\cite{boixo:18}


\section{Generation of random circuits}

Random circuits can be generated by sampling gates from a universal gate set. The exact form of this sampling will be designed for specific requirements, such as building up long range entanglement as quickly as possible ~\cite{boixo:18}.

In this work, we study circuits for which the speed at which entanglement builds up can be tuned. We also require that the output of the circuit should possess certain structure in cases for which long range entanglement and noise is not present. The loss of this structure can then be used to assess the build up of these effects.

We build up circuits as a series of \textit{rounds}, each of which is composed of a pair of \textit{slices}. As each round is added, the circuit so far is implemented. The results of these runs are then used to inform the further build-up of the circuit. Specifically, the first run of the circuit uses only the first slice of the first round. The results are then used to define the second slice of the first round. The next run then implements the whole of the first round, followed by the first slice of the second. The results are used to define the second slice of the second round, and so on.

The first slice of each round is the main point at which randomly generated entangling gates are introduced into the circuit. This is done by first randomly choosing a set of disjoint pairs of qubits. This pairing should be based on the connectivity of the device used: it should be possible to directly implement a controlled gate between the two qubits of each pair. In the case that the device has an odd number of qubits, or if the connectivity requires it, some qubits can be left unpaired.

Next, a random entangling gate is generated for each pair of qubits $(j,k)$. This will take the form

\be
\mathtt{cx} (j,k) \, \exp [ \, i \theta_{j,k} \sigma^j_x \, ] \, \mathtt{cx}(j,k) = \exp [ \, i \theta_{j,k} \, \sigma^j_x \sigma^k_x \, ]
\ee

Here $\mathtt{cx}(j,k)$ denotes a controlled-NOT with $j$ as control and $k$ as target. The angles $\theta_{j,k}$ are chosen randomly from the range $\pi/20 \leq \theta \leq \pi/2$. The effect of these gates on the initial all $\ket{0}$ will be to create entangled pairs of the form
\be \label{state}
\cos (\theta_{j,k}) \ket{00} + i \sin (\theta_{j,k}) \ket{11} .
\ee
For such pairs, note that $Z$ basis measurement of the two qubits will always yield the same result. The probability that this result is $\ket{1}$ is
\be \label{eq:prob}
p_j = p_k = \sin^2 (\theta_{j,k}).
\ee
The range of allowed values of $\theta$ will yield values of $p$ between $0.024$ and $1$. The lower bound was chosen to ensure a degree of distinction between qubits involved in pairs (and therefore an entangling gate) and those left unpaired (and therefore with no gate applied).

The structure of this output should make it possible to deduce the random gates applied using only the values of $p_j$ for each qubit. These can be used to deduce the pairing using the fact that $p_j=p_k$ for each pair $(j,k)$. The value of $\theta_{j,k}$ can then be deduced by inverting Eq. \ref{eq:prob}. With this information, a set of inverse gates can be constructed. An attempt to implement such an inverse forms the second slice of each round.

It is important to note the deduced inverse will not be a true inverse in general. Reasons for this include:
\begin{itemize}
\item Noise in the implementation, such as imperfect gates and decoherence, will perturb the measured $p_j$ from their ideal values;
\item The finite number of samples used to estimate the $p_j$ will lead to statistical noise;
\item The use of a faulty method to construct the inverses;
\item Failures in the inverses of previous rounds will result in the entangling slice not being applied to the all $\ket{0}$ state, and so Eq. \ref{prob} applies only approximately.
\end{itemize}
In preventing the first slice of each round from being fully inverted, these effects allow randomness to build up in the circuits. By choosing how strong these effects are, we can tune the speed at which entanglement builds up throughout the circuit.

Note that each round, as defined thus far, is completely diagonal in the $\sigma_x$ basis of all qubits. Using oly such gates will not allow us to fully explore the Hilbert space of the device. The finishing touch for each round will therefore be to conjugate completed rounds with random single qubit gates. Each of these is randomly chosen to be either an $x$ or $y$ axis rotation, and with a randomly chosen angle $0\leq\phi\leq\pi$. The random circuits generated by this process could then be used within an experimental verification of quantum computational supremacy~\cite{boixo}.


\section{Figures of merit}

With the results from running the circuit for each round we can assess the build up of entangled states. This will primarily be done by looking at how well the output can be used to deduce the inverse of the most recent slice of randomly chosen entangling gates. Highly successful construction of the inverse implies that long range entanglement is negligible, and that the state immeditaley prior to the most recent slice was close to the all $\ket{0}$ state. The relation of Eq. \ref{prob}, and all conclusions derived from it, will then hold to good approximation.

On the other hand, highly unsuccessful construction of the inverse implies that final output is dominated by other effects. In the best case, this will be long range entanglement built up by the random circuit. In the worst case, it will be noise. By comparison of random circuits for which entanglement is generated at different rates, we can attempt to distinguish these to possibilities.

\subsection{Fuzz}

The first way we will quantify an ouput is to compare the calculated values of $\tilde{p_j}$ and $\tilde{p_k}$ for each pair in the most recent slice. If Eq. \ref{prob} holds, we will have $\tilde{p_j}=\tilde{p_k}$ in each case. However, as Eq. \ref{prob} becomes an increasingly worse approximation, these numbers will begin to drift away from each other. We refer to this as \textit{fuzz}, and quantify it as follows over the whole device
\be
\mathtt{fuzz} = \sum_{(j,k)} | \tilde{p_j} - \tilde{p_k} | / n.
\ee
Here $n$ is the number of pairs of qubits on the device (and so half the total number of qubits when this is even and the connectivity allows).

Note that, for the first round, the fuzz will be at or close to zero. It will then begin to rise as Eq. \ref{prob} becomes more approximate. At the other extreme, after an arbitrarily large number of rounds all $\tilde{p_j}$ will converge at close to $1/2$. This will ideally be due to the random circuit causing the final state to be a typical sample drawn uniformly from the multiqubit Hilbert space. However, it could also be due to the build up of noise. In either case, the fact that all $\tilde{p_j}$ have converged to the same value will also cause a low value of the fuzz.

Given this behaviour, there will neccesarily be a peak in a graph of fuzz against round number. This will be the most noticable feature in our results. It essentially marks the start of the inevitable march towards a completely random output without the structure require for inverses to be successfully deduced.

We will look at the build-up of fuzz for each device in two different cases: inverses constructed when the assumed pairing of the qubits is completely correct, and those constructed when the assumed pairing is chosen completely randomly and without reference to the results. In the absence of noise, the inverses in the latter case will be perfect up to statistical noise. This can be suppressed arbitrarily by increasing the number of samples used to calculate the $\tilde{p_j}$. For the latter case, however, the fuzz will rise sharply and peak early. This is because the second slice of each round is essentially as much a source of random gates as the first, and has little effect as an inverse.

In both cases, the assumed $\theta_{j,k}$ to be inverted are calulated from Eq. \ref{prob} using $(\tilde{p_j}+\tilde{p_k})/2$. For simulated instances for which the correct pairs are used, statistical noise is emulated by having the $\theta_{j,k}$ for the inverses differ from the correct value by $0.1/\sqrt{\mathtt{shots}}$, where $\mathtt{shots}$ is the number of samples used to calculate the $\tilde{p_j}$.

By looking at the fuzz for these two cases, we can assess how well a device a device might be able to uniformly sample states from its multiqubit Hilbert space. This can be done most quickly using the case of randomly chosen pairs. The creation of the desired states required the fuzz to first peak, and then subsequently vanish. However, this same behaviour will be seen for devices dominated by noise. To determine which of these two possibilities occurred, we can run the process with correctly chosen pairs over the same number of rounds. If the noise is dominant, the fuzz will again be seen to peak and vanish. If noise is neglible, however, and a large sample size is used, the increase in fuzz will be only very slight.

In summary, this shows that we would like to see devices for which the fuzz peak for correctly chosen pairs occurs at a much higher round than than for randomly chosen pairs. Indeed, if the peak in the former case is still yet to occur when the fuzz for the latter case has vanished, it becomes very plausible that the device could provide a strong demonstation of uniform sampling from the multiqubit Hilbert space. For a sufficiently large device, this would imply the ability for a strong demonstration of quantum computational supremacy.

Prior to this, we can also define a weaker condition: one that we call `quantum competenceâ€™. To satisfy this, a device should have the fuzz peak for correctly chosen pairs at a higher round than for randomly chosen pairs would on an identical but noiseless device. If this condition is not satisfied, it means that the strength of noise in the former case is stronger than the fact that the entangling gates are supplemented rather than inverted in the latter case. This would be evidence of noise with highly deleterious effects. Acheiving quantum comptence for ever larger devices is therefore very much a minimal aim for the development of quantum computing hardware.

\subsection{Pairing with MWPM}

We will now consider how well the pairing can be deduced for a given output. We will do this using minimum weight perfect matching on the connectivity graph of the device. For each pair of qubits we assign a weight that depends on the measured values of $\tilde{p_j}$,
\be \label{angle}
W_{j,k} = | \tilde{\theta_j} - \tilde{\theta_k} |, \,\, \tilde{\theta_j} = \sin^{-1}( \sqrt{\tilde{p_j}} ).
\ee
The minimum weight matching will find the pairing that minimizes this weight, and therefore minimizes the differences between the $p_j$ values. Since the $p_j$ values for the two qubits within each pair should be equal, peforming this minimization should provide a near optimal means of finding the pairs. The percentage of pairs correctly found my this method will be used as a further way of analysing the progess of our random circuits.

\subsection{Difference with ideal values}

The main result taken from the output is the measured probabilities $\tilde{p_j}$. It therefore makes sense to compare these directly to their ideal values. Specifically, we will calculate the difference between the corresponding $\tilde{\theta_j}$ and the actual angle $\theta_{j,k}$ used for the pair that qubit $j$ is a part of. This will also be averaged over the entire device to give a measure of how well the qubits correspond to the values they would take if only the most recent entangling slice was implemented, and implemented perfectly.

\subsection{Error mitigation}

Thus far we have used only one of the properties of the states described in Eq. \ref{state}: the fact that $p_j=p_k$. However, it is further true that the results for paired qubits $j$ and $k$ should be perfectly correlated. This provides a further means by which pairs can be identified from the data. Specifically, the mutual information $I(j;k)$ for measurement outcomes will be non-zero if and only if the qubits are paired. For a given qubit $j$, the most likely qubit $kâ€™$ for it to be paired with is that with the highest value of $I(j;kâ€™)$. Let us refer to this as qubit $c(j)$.

This information could then be used mitigate for effects that cause violations of Eq. \ref{prob}, to minimize build-up of fuzz and maximize the effectiveness of MWPM. Instead of using the measured values of the $\tilde{p_j}$, we could instead use
\be
\bar{p_j} = \frac{ \tilde{p_j} + \tilde{p_k} }{2}
\ee
For cases in which two qubits are each most correlated with the other (i.e. $c(j)=k$ and $c(k)=j$), the resulting values of $\bar{p_j}$ and $\bar{p_k}$ will be equal. Assuming that the mutual informations can be used to correctly deduce pairings in most cases, this will result in significant improvements to results.


\section{Results}

\subsection{Example devices}

\subsection{5 and 16 qubit IBM devices}

\subsection{19 qubit Rigetti device}

\subsection{11 qubit Alibaba device}



\section{Conclusions}


%\begin{figure}[t]
%\begin{center}
%{\includegraphics[width=\columnwidth]{device.png}}
%\caption{\label{device} The layout of the \emph{ibmqx3} device, with the numbering of qubits used in this study. Lines connect pairs of qubits for which a CNOT can be performed. Thick black lines are show for the CNOTs used in our implementation of the repetition code.
%}
%\end{center}
%\end{figure}




\section{Acknowledgements}

This work was supported by the Swiss National Science Foundation and the NCCR QSIT.

Results for this work were generated using the IBM Q Experience and QISKit, Rigettiâ€™s was used to produce results for this work. The views expressed are those of the authors and do not reflect the official policy or position of IBM or the IBM Quantum Experience team.


\bibliography{refs}


\end{document}
